import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from cachetools import TTLCache
import aiohttp
import numpy as np
import tensorflow.lite as tflite
from dotenv import load_dotenv

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
load_dotenv()
TOKEN = os.getenv("TELEGRAM_TOKEN")
MODEL_PATH = "optimized_model.tflite"
API_URL = "https://api.football-data.org/v4/matches" # –ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª—å–Ω–æ–≥–æ API
CACHE = TTLCache(maxsize=500, ttl=600)

# –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏
interpreter = tflite.Interpreter(model_path=MODEL_PATH)
interpreter.allocate_tensors()

async def fetch_stats(team: str) -> dict:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ–∂–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ–º–∞–Ω–¥—ã"""
    headers = {"X-Auth-Token": os.getenv("API_TOKEN")}
    async with aiohttp.ClientSession() as session:
        async with session.get(f"{API_URL}?team={team}", headers=headers) as resp:
            return await resp.json()

async def predict(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –º–µ–Ω—é"""
    keyboard = [
        [InlineKeyboardButton("‚öΩ –í—ã–±—Ä–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã", callback_data="select_teams")],
        [InlineKeyboardButton("üìä –ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø—Ä–æ–≥–Ω–æ–∑—ã", callback_data="history")]
    ]
    await update.message.reply_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "select_teams":
        await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n\n–ö–æ–º–∞–Ω–¥–∞1 vs –ö–æ–º–∞–Ω–¥–∞2")

async def enhanced_predictor(team1: str, team2: str) -> dict:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–≥–Ω–æ–∑"""
    try:
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        stats1 = await fetch_stats(team1)
        stats2 = await fetch_stats(team2)
        
        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è –º–æ–¥–µ–ª–∏
        input_data = np.array([[stats1['form'], stats2['form'], 
                             stats1['goals'], stats2['goals']]], 
                            dtype=np.float32)
        
        # –õ–æ–∫–∞–ª—å–Ω—ã–π –ø—Ä–æ–≥–Ω–æ–∑
        interpreter.set_tensor(interpreter.get_input_details()[0]['index'], input_data)
        interpreter.invoke()
        prediction = interpreter.get_tensor(interpreter.get_output_details()[0]['index'])
        
        # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
        confidence = float(prediction[0][0])
        progress_bar = "üü©" * int(confidence * 10) + "‚¨úÔ∏è" * (10 - int(confidence * 10))
        
        return {
            "text": f"{progress_bar}\n–®–∞–Ω—Å –ø–æ–±–µ–¥—ã {team1}: {confidence:.0%}",
            "image": generate_prediction_chart(team1, team2, confidence) # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥—Ä–∞—Ñ–∏–∫–∞
        }
    
    except Exception as e:
        logger.error(f"Prediction error: {e}")
        return {"text": "‚ö†Ô∏è –û—à–∏–±–∫–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥!"}

def main():
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", predict))
    app.add_handler(CallbackQueryHandler(handle_button))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.run_polling()
